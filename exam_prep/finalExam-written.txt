##  Q1:
A vulnerable website, even if unimportant, could lead to a successful CSRF attack.
For example, an attacker could insert code that will be executed in a victim’s browser, leading to a successful request being made to a much more important website, e.g., a bank transfer, an email being sent in the user’s name, or public posts being made in the user’s name with malicious content.That is, the effects of a successful attack can go beyond the website itself, which is why it’s important to secure it in any case

## Q2:
A clear advantage of whitebox testing is that the internal state of a system can be assessed. That means it can be ensured that operations not only return the right values, but also change the state internally according to the return values. Many different errors exist that could cause internal changes that lead to incorrect behavior later on, but do not affect the immediate return values that would be assessed in black-box testing. A disadvantage of white-box testing is the effort and complexity: Setting up fixtures to monitor what the system is doing internally can be complicated depending on the used technology (such as databases), and can affect the system performance in a negative way.

## Q3:
To address the first part (no replay attack to another endpoint), we need to include something in the signature that uniquely identifies the endpoint we are sending a request to. Most suitable would be the HTTP method verb and the path to the endpoint. Using only one of the two would allow making a successful replay attack to any endpoint that differs in the part that has been omitted. For instance, if we skip the verb, we could make a replay attack to an endpoint with the same path but different verb. To address the second part (no replay attack with different request body), we also need to include the request body in the HMAC signature. This makes sure that any request body that differs will lead to another signature on the server, thus causing an error if the signature for another request body was replayed

## Q4:
Idempotence means that the state of the server remains the same if the request is executed multiple times in comparison to one time only. In the case of a Delete request, the resource is deleted the first time the request is made. The second time the request is made (and subsequently afterwards) no more changes are made to the resources on the server, so that state remains identical. In the concrete case, let’s assume we have the two eateries present in the original backend, and delete the one with id 3 (“Elliðaárdalur”). The request will be successful (response code 201) and delete the eatery on the backend, resulting in only one eatery being left (id 1). If we repeat the request, the server will not delete anything (response code 404), but the state on the server remains the same: one eatery being left. Note that idempotence does not require that the responses are identical for multiple requests.

## Q5:
The POST request in the backend lacks a number of checks. First, there are (depending on implementation) no means to sanitize input strings. Second, the logo expects any kind of URL. Together, this allows an attacker to insert HTML code that will then be reflected when the page is loaded by someone else. If, e.g., the innerHTML attribute is used to display eatery names and descriptions, we could insert JavaScript code into the website, which will be executed on any client’s browser loading it. If this JavaScript code includes any kind of requests to other websites, these will be executed (the “Cross-site” scripting attack). Such an attack can have a number of consequences, such as defacing (offensive or revealing posts are made in the name of the user on other websites), financial loss (orders are placed in the name of the user, bank transfers made), or legal consequences (illegal actions are executed through the user’s computer).